package mn

import (
	"log"
	"reflect"
	"testing"

	"github.com/NodePrime/open-mininet/pool"
)

func init() {
	log.SetFlags(log.Lshortfile)
}

func TestProperties(t *testing.T) {
	n1, err := NewSwitch("left")
	if err != nil {
		t.Fatal(err)
	}

	n2, err := NewHost("right")
	if err != nil {
		t.Fatal(err)
	}

	// pool.ThePool("192.168.44.1/24")

	defer func() {
		var err error
		if err = n1.Release(); err != nil {
			log.Println(err)
		}
		if err = n2.Release(); err != nil {
			log.Println(err)
		}

	}()

	expected1 := Link{
		Cidr:     "192.168.44.1/24",
		HwAddr:   "00:00:00:00:00:00",
		Name:     "left-eth0",
		NodeName: "left",
		NetNs:    "",
		State:    "DOWN",
		Routes:   []Route{{Dst: "0.0.0.0/0", Gw: "192.168.44.1"}},
	}
	expected2 := Link{
		Cidr:     "192.168.44.2/24",
		HwAddr:   "00:00:00:00:00:00",
		Name:     "veth0",
		NodeName: "right",
		NetNs:    "right",
		State:    "DOWN",
		Routes:   []Route{{Dst: "0.0.0.0/0", Gw: "192.168.44.1"}},
	}

	result := Pair{
		Left:  Link{HwAddr: "00:00:00:00:00:00", Cidr: "192.168.44.1/24", Routes: []Route{{Dst: "0.0.0.0/0", Gw: "192.168.44.1"}}},
		Right: Link{HwAddr: "00:00:00:00:00:00", Cidr: "192.168.44.2/24", Routes: []Route{{Dst: "0.0.0.0/0", Gw: "192.168.44.1"}}},
	}

	p1 := result.Left.SetCidr().SetHwAddr().SetNodeName(n1).SetName(n1, "eth").SetState("DOWN").SetRoute()
	p2 := result.Right.SetCidr().SetHwAddr().SetNodeName(n2).SetNetNs(n2).SetName(n2, "eth").SetState("DOWN").SetRoute()

	if !reflect.DeepEqual(expected1, p1) {
		t.Fatal("\nExpected:", expected1, "\nObtained:", p1)
	}

	if !reflect.DeepEqual(expected2, p2) {
		t.Fatal("\nExpected:", expected2, "\nObtained:", p2)
	}
}

func TestLink(t *testing.T) {
	h1, err := NewSwitch()
	if err != nil {
		t.Fatal(err)
	}

	defer h1.Release()

	h2, err := NewHost(hostname())
	if err != nil {
		t.Fatal(err)
	}

	defer h2.Release()

	cases := []struct {
		refs     []Link
		expected Pair
	}{
		{
			refs: []Link{Link{Cidr: "192.168.66.1/24", Routes: []Route{}}, Link{Cidr: "192.168.66.2/24", Routes: []Route{{"0.0.0.0/0", "192.168.66.1"}}}},
			expected: Pair{
				Link{
					"192.168.66.1/24",
					"00:00:00:00:00:00",
					h2.NodeName() + "-eth0",
					h1.NodeName(),
					"",
					"DOWN",
					[]Route{},
					"",
					Peer{
						Name:     "veth0",
						IfName:   "veth0",
						NodeName: h2.NodeName(),
					},
					false,
					false,
				},
				Link{
					"192.168.66.2/24",
					"00:00:00:00:00:00",
					"veth0",
					h2.NodeName(),
					h2.NodeName(),
					"DOWN",
					[]Route{{"0.0.0.0/0", "192.168.66.1"}},
					"",
					Peer{
						Name:     h2.NodeName() + "-eth0",
						IfName:   h2.NodeName() + "-eth0",
						NodeName: h1.NodeName(),
					},
					false,
					false,
				},
			},
		},
	}

	emptyifnil := func(n *NetNs) string {
		if n == nil {
			return ""
		}

		return n.Name()
	}

	for _, c := range cases {
		pair := NewLink(h1, h2, c.refs...)
		// hack, cause macs are autogenerated
		c.expected.Left.HwAddr = pair.Left.HwAddr
		c.expected.Right.HwAddr = pair.Right.HwAddr

		if !reflect.DeepEqual(c.expected, pair) {
			t.Fatal("\nExpected:\n", c.expected, "\nObtained:\n", pair)
		}

		if err := pair.Create(); err != nil {
			t.Fatal(err)
		}

		if ifaceNotExists(pair.Left.Name, emptyifnil(h1.NetNs())) {
			t.Fatal("Expected link", pair.Left.Name, "not found in netns", emptyifnil(h1.NetNs()))
		}

		if ifaceNotExists(pair.Right.Name, emptyifnil(h2.NetNs())) {
			t.Fatal("Expected link", pair.Right.Name, "not found in netns", emptyifnil(h2.NetNs()))
		}

		if err := pair.Left.Up(); err != nil {
			t.Fatal(err)
		}

		if err := pair.Right.Up(); err != nil {
			t.Fatal(err)
		}

		// if err := pair.Left.ApplyMac(); err != nil {
		// 	t.Fatal(err)
		// }

		// if err := pair.Right.ApplyMac(); err != nil {
		// 	t.Fatal(err)
		// }

		if !ifaceUp(pair.Left.Name, emptyifnil(h1.NetNs())) {
			t.Fatal("Expecting link", pair.Left.Name, "is up")
		}

		if !ifaceUp(pair.Right.Name, emptyifnil(h2.NetNs())) {
			t.Fatal("Expecting link", pair.Right.Name, "is up")
		}

		if err := pair.Left.ApplyCidr(); err != nil {
			t.Fatal(err)
		}

		if !ifaceAddr(pair.Left.Name, emptyifnil(h1.NetNs()), pair.Left.Ip()) {
			t.Fatal("Expecting ipv4", pair.Left.Ip(), "not found")
		}

		if err := pair.Right.ApplyCidr(); err != nil {
			t.Fatal(err)
		}

		if err := pair.Right.ApplyRoutes(); err != nil {
			t.Fatal(err)
		}

		if !routeExists(c.refs[1].Routes, emptyifnil(h2.NetNs())) {
			t.Fatal("Expected routes", c.refs[1].Routes, "not found")
		}

		if !ifaceAddr(pair.Right.Name, emptyifnil(h2.NetNs()), pair.Right.Ip()) {
			t.Fatal("Expecting ipv4", pair.Left.Ip(), "not found")
		}
	}
}

func TestPatchPort(t *testing.T) {
	s1, err := NewSwitch("s1")
	if err != nil {
		t.Fatal(err)
	}
	defer s1.Release()

	s2, err := NewSwitch("s2")
	if err != nil {
		t.Fatal(err)
	}
	defer s2.Release()

	expected := Pair{
		Left: Link{
			Name:     "s1-pp0",
			NodeName: "s1",
			Peer: Peer{
				NodeName: "s2",
				IfName:   "s2-pp0",
				Name:     "s2-pp0",
			},
			patch: true,
		},
		Right: Link{
			Name:     "s2-pp0",
			NodeName: "s2",
			Peer: Peer{
				NodeName: "s1",
				IfName:   "s1-pp0",
				Name:     "s1-pp0",
			},
			patch: true,
		},
	}

	p := NewLink(s1, s2)

	if !reflect.DeepEqual(expected, p) {
		t.Fatal("\nExpected:", expected, "\nObtained:", p)
	}

	if err := s1.AddPatchPort(p.Left); err != nil {
		t.Fatal(err)
	}

	if err := s2.AddPatchPort(p.Right); err != nil {
		t.Fatal(err)
	}
}

func TestHostToHost(t *testing.T) {
	pool.ThePool("192.168.55.1/24")

	h1, err := NewHost()
	if err != nil {
		t.Fatal(err)
	}
	defer h1.Release()

	h2, err := NewHost()
	if err != nil {
		t.Fatal(err)
	}
	defer h2.Release()

	p := NewLink(h1, h2)

	if err := p.Create(); err != nil {
		t.Fatal(err)
	}

	p, err = p.Up()
	if err != nil {
		t.Fatal(err)
	}

	h1.AddLink(p.Left)
	h2.AddLink(p.Right)

	if err := ping(h1, h2); err != nil {
		t.Fatal("Ping failed:", err)
	}
}
